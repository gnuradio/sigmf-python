# Copyright: Multiple Authors
#
# This file is part of sigmf-python. https://github.com/sigmf/sigmf-python
#
# SPDX-License-Identifier: LGPL-3.0-or-later

# generated by datamodel-codegen:
#   filename:  schema-meta.json
#   timestamp: 2024-05-27T20:41:41+00:00
"""Metadata file components validated using Pydantic."""

import warnings
from uuid import uuid1
from pathlib import Path
from datetime import datetime as datetime_type  # renamed to not clash with captures.datetime
from typing import List, Optional, Dict, Any, Union
from typing_extensions import Annotated

from pydantic import (
    BaseModel,
    Field,
    ConfigDict,
    field_validator,
    model_validator,
    field_serializer,
    NonNegativeInt,
    PositiveInt,
    UUID1,
    HttpUrl,
)

# local imports
from sigmf import __version__
from sigmf.error import SigMFFileError
from sigmf.component.geo_json import GeoJSONPoint
from sigmf.component.pydantic_types import VERSION_STR, DATATYPE_STR, DOI_STR, FREQUENCY_TYPE
from sigmf.component.extensions.core import SigMFCoreExtension


class SigMFGlobalInfo(BaseModel):
    """Global information object."""

    # allow extras.
    model_config = ConfigDict(extra="allow")

    datatype: DATATYPE_STR = Field(
        ...,
        alias="core:datatype",
        description="The SigMF Dataset format of the stored samples in the Dataset file.",
        examples=["ri16_le", "cf32_be"],
    )
    version: VERSION_STR = Field(
        default_factory=lambda: __version__,
        alias="core:version",
        description="The version of SigMF for this recording.",
    )
    author: Optional[str] = Field(
        None,
        alias="core:author",
        description="A text identifier for the author potentially including name, handle, "
        "email, and/or other ID like Amateur Call Sign.",
        examples=["Bruce Wayne bruce@waynetech.com", "Bruce (K3X)"],
    )
    collection: Optional[Path] = Field(
        None,
        alias="core:collection",
        description="The base filename of a `collection` with which this Recording is associated.",
    )
    dataset: Optional[Path] = Field(
        None, alias="core:dataset", description="The full filename of the Dataset file this Metadata file describes."
    )
    data_doi: Optional[DOI_STR] = Field(
        None, alias="core:data_doi", description="The registered DOI (ISO 26324) for a Recording's Dataset file."
    )
    description: Optional[str] = Field(
        None, alias="core:description", description="A text description of the SigMF Recording."
    )
    hw: Optional[str] = Field(
        None, alias="core:hw", description="A text description of the hardware used to make the Recording."
    )
    license: Optional[HttpUrl] = Field(
        None,
        alias="core:license",
        description="A URL for the license document under which the Recording is offered.",
        examples=["https://creativecommons.org/licenses/by-sa/4.0/"],
    )
    metadata_only: Optional[bool] = Field(
        None,
        alias="core:metadata_only",
        description="Indicates the Metadata file is intentionally distributed without the Dataset.",
    )
    meta_doi: Optional[DOI_STR] = Field(
        None, alias="core:meta_doi", description="The registered DOI (ISO 26324) for a Recording's Metadata file."
    )
    num_channels: Optional[PositiveInt] = Field(
        1,
        alias="core:num_channels",
        le=1000,  # less than or equal to 1000
        description="Total number of interleaved channels in the Dataset file. If omitted, this defaults to one.",
    )
    offset: Optional[NonNegativeInt] = Field(
        None,
        alias="core:offset",
        description="The index number of the first sample in the Dataset. If not provided, this "
        "value defaults to zero. Typically used when a Recording is split over multiple files. "
        "All sample indices in SigMF are absolute, and so all other indices referenced in metadata "
        "for this recording SHOULD be greater than or equal to this value.",
    )
    recorder: Optional[str] = Field(
        None, alias="core:recorder", description="The name of the software used to make this SigMF Recording."
    )
    sample_rate: Optional[float] = Field(
        None, alias="core:sample_rate", description="The sample rate of the signal in samples per second."
    )
    sha512: Optional[str] = Field(
        None,
        alias="core:sha512",
        max_length=128,
        description="The SHA512 hash of the Dataset file associated with the SigMF file.",
    )
    trailing_bytes: Optional[NonNegativeInt] = Field(
        None,
        alias="core:trailing_bytes",
        description="The number of bytes to ignore at the end of a Non-Conforming Dataset file.",
    )
    geolocation: Optional[GeoJSONPoint] = Field(
        None,
        alias="core:geolocation",
        description="The location of the recording system, as a single RFC 7946 GeoJSON ‘point‘ "
        "Object using the convention defined by RFC 5870.",
    )
    extensions: Optional[List[SigMFCoreExtension]] = Field(
        None,
        alias="core:extensions",
        description="The `core:extensions` field in the Global Object is an array of extension "
        "objects that describe SigMF extensions. Extension Objects MUST contain the three key/value "
        "pairs defined below, and MUST NOT contain any other fields.",
    )

    # validators
    @field_validator("dataset")
    @classmethod
    def validate_dataset(cls, value: Optional[Path]) -> Optional[Path]:
        """Validates that dataset (if it exists) is set."""
        if value is not None:
            # validate sigmf ending.
            if value.suffix != ".sigmf-data":
                # changes extension to .sigmf-data.
                value = value.with_suffix(".sigmf-data")
            # check whether the file exists.
            if not value.is_file():
                # check whether the file exists, and if not, raise a warning.
                warnings.warn(f"Non-Compliant Dataset `{value}` is specified " 'in "core:dataset" but does not exist!')
        return value

    @field_validator("collection")
    @classmethod
    def validate_collection(cls, value: Optional[Path]) -> Optional[Path]:
        """Validates that dataset (if it exists) is set."""
        if value and not value.exists():
            warnings.warn(f"Non-Compliant Dataset `{value}` is specified " 'in "core:collection" but does not exist!')
        return value

    @model_validator(mode="after")
    def check_dataset_metadata_mutually_exclusive(self) -> "SigMFGlobalInfo":
        """Validates the whole object after creation."""
        # check that core:dataset and core:metadata_only are mutually exclusive.
        if self.dataset is not None and self.metadata_only is not None:
            warnings.warn('Both "core:dataset" and "core:metadata_only" are defined: defaulting to "core:dataset"')
        return self

    # special serializers
    @field_serializer("dataset", "collection")
    def serialize_dataset(self, file_path: Optional[Path], _info) -> Optional[str]:
        """Serializes core:dataset into a string prior to dictionary conversion."""
        return file_path.name if file_path else None

    @field_serializer("license")
    def serialize_license(self, url: Optional[HttpUrl], _info) -> Optional[str]:
        """Serializes core:license into a string prior to dictionary conversion."""
        return url.unicode_string() if url else None


class SigMFCapture(BaseModel):
    """A single SigMF capture containing core properties."""

    model_config = ConfigDict(extra="allow")

    sample_start: NonNegativeInt = Field(
        ..., alias="core:sample_start", description="Index of first sample of this chunk."
    )
    frequency: Optional[FREQUENCY_TYPE] = Field(
        None, alias="core:frequency", description="The center frequency of the signal in Hz."
    )
    datetime: Optional[datetime_type] = Field(
        default_factory=datetime_type.now,
        alias="core:datetime",
        description="An ISO-8601 string indicating the timestamp of the sample index specified by sample_start.",
        examples=["1955-11-05T14:00:00.000Z"],
    )
    global_index: Optional[NonNegativeInt] = Field(
        None,
        alias="core:global_index",
        description="The index of the sample referenced by `sample_start` relative to an original sample stream.",
    )
    header_bytes: Optional[NonNegativeInt] = Field(
        None,
        alias="core:header_bytes",
        description="The number of bytes preceding a chunk of samples that are not sample data, used for NCDs.",
    )

    @field_serializer("datetime")
    def serialize_datetime(self, dt_attr: Optional[datetime_type], _info) -> Optional[str]:
        """Serializes a ISO8601 datetime string."""
        return dt_attr.isoformat() + "Z" if dt_attr else None


class SigMFAnnotation(BaseModel):
    """A single SigMF annotation containing core properties."""

    model_config = ConfigDict(extra="allow")

    sample_start: NonNegativeInt = Field(
        ..., alias="core:sample_start", description="The sample index at which this Segment takes effect."
    )
    sample_count: Optional[PositiveInt] = Field(
        None, alias="core:sample_count", description="The number of samples that this Segment applies to."
    )
    comment: Optional[str] = Field(None, alias="core:comment", description="A human-readable comment.")
    freq_lower_edge: Optional[FREQUENCY_TYPE] = Field(
        None,
        alias="core:freq_lower_edge",
        description="The frequency (Hz) of the lower edge of the feature described by this annotation.",
    )
    freq_upper_edge: Optional[FREQUENCY_TYPE] = Field(
        None,
        alias="core:freq_upper_edge",
        description="The frequency (Hz) of the upper edge of the feature described by this annotation.",
    )
    generator: Optional[str] = Field(
        None, alias="core:generator", description="Human-readable name of the entity that created this annotation."
    )
    label: Annotated[
        Optional[str],
        Field(
            None,
            alias="core:label",
            description="A short form human/machine-readable label for the annotation.",
            max_length=20,
        ),
    ]
    uuid: Annotated[
        Optional[UUID1],
        Field(default_factory=uuid1, alias="core:uuid", description="RFC-4122 unique identifier."),
    ]

    @field_serializer("uuid")
    def serialize_uuid(self, uuid: Optional[UUID1], _info) -> Optional[str]:
        """Serializes UUID string into 32-character hex."""
        return uuid.urn if uuid else None

    @model_validator(mode="after")
    def check_freq_upper_greater_lower(self) -> "SigMFAnnotation":
        """Checks whether frequency_upper is >= frequency_lower."""
        if self.freq_lower_edge and self.freq_upper_edge and self.freq_upper_edge < self.freq_lower_edge:
            warnings.warn("`freq_upper_edge` must be >= `freq_lower_edge`")
        return self


class SigMFMetaFileSchema(BaseModel):
    """SigMF Meta File.

    Defines `global`, `captures` and `annotations`.
    """

    # forbid extra fields.
    model_config = ConfigDict(extra="forbid")

    global_info: SigMFGlobalInfo = Field(
        ...,
        alias="global",
        description="The `global` object consists of key/value pairs that provide information applicable "
        "to the entire Dataset. It contains the information that is minimally necessary to open and parse "
        "the Dataset file, as well as general information about the Recording itself.",
    )
    captures: Optional[List[SigMFCapture]] = Field(
        None,
        min_length=1,
        description="The `captures` value is an array of capture segment objects that describe the "
        "parameters of the signal capture. It MUST be sorted by the value of each capture segment's "
        "`core:sample_start` key, ascending.",
    )
    annotations: Optional[List[SigMFAnnotation]] = Field(
        None,
        min_length=1,
        description="The `annotations` value is an array of annotation segment objects that describe "
        "anything regarding the signal data not part of the Captures and Global objects. It MUST be "
        "sorted by the value of each Annotation Segment's `core:sample_start` key, ascending.",
    )

    @model_validator(mode="before")
    @classmethod
    def sort_by_sample_start(cls, data: Dict[str, Any]) -> Dict[str, Any]:
        """Sorts the list of captures by `sample_start` before parsing."""
        if "captures" in data:
            # sorts the captures based on `sample_start` key.
            data["captures"] = sorted(data["captures"], key=lambda item: item["core:sample_start"])
        if "annotations" in data:
            # sorts the annotations based on `sample_start` key.
            data["annotations"] = sorted(data["annotations"], key=lambda item: item["core:sample_start"])
        return data

    @classmethod
    def from_file(cls, file_path: Union[str, Path]) -> "SigMFMetaFileSchema":
        """Loads a SigMF Metadata File.

        Only accepts .sigmf-meta files.

        Parameters
        ----------
        file_path : str or Path
            Filepath and filename (with suffix) to SigMF file.

        Returns
        -------
        obj : SigMFMetaFileSchema
            Defined pydantic object.
        """
        # convert to pathlib.
        file_path = Path(file_path).with_suffix(".sigmf-meta")

        # check if file exists.
        if not file_path.is_file():
            raise SigMFFileError(f"File at `{file_path}` does not exist.")

        # now read in file - raises JSON parsing error if something is wrong.
        with open(file_path, "rt", encoding="utf-8") as json_file:
            json_data = json_file.read()

        # parse the json string into a Pydantic object...
        # raises Pydantic.ValidationErrors for every problem.
        metafile = SigMFMetaFileSchema.model_validate_json(json_data)
        return metafile
